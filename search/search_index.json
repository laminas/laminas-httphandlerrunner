{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-httphandlerrunner This library provides utilities for: Emitting PSR-7 responses. Running PSR-15 server request handlers, which involves marshaling a PSR-7 ServerRequestInterface , handling exceptions due to request creation, and emitting the response returned by the composed request handler. The RequestHandlerRunner will be used in the bootstrap of your application to fire off the RequestHandlerInterface representing your application. Installation Run the following to install this library: $ composer require laminas/laminas-httphandlerrunner Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Home"},{"location":"#laminas-httphandlerrunner","text":"This library provides utilities for: Emitting PSR-7 responses. Running PSR-15 server request handlers, which involves marshaling a PSR-7 ServerRequestInterface , handling exceptions due to request creation, and emitting the response returned by the composed request handler. The RequestHandlerRunner will be used in the bootstrap of your application to fire off the RequestHandlerInterface representing your application.","title":"laminas-httphandlerrunner"},{"location":"#installation","text":"Run the following to install this library: $ composer require laminas/laminas-httphandlerrunner","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"emitters/","text":"Emitters Emitters are used to emit a PSR-7 response. This should generally happen when running under a traditional PHP server API that uses output buffers, such as Apache or php-fpm. Emitters are described by Laminas\\HttpHandlerRunner\\Emitter\\EmitterInterface : use Psr\\Http\\Message\\ResponseInterface; interface EmitterInterface { public function emit(ResponseInterface $response) : bool; } Typically, such emitters will perform the following: Emit a response status line. Emit all response headers. Emit the response body. (The first two items may be swapped in order; many SAPIs allow emitting multiple status lines, and will use the last one present. As such, most implementations will emit the status line after the headers to ensure the correct one is emitted by the SAPI.) The emit() method allows returning a boolean. This value can be checked to determine if the emitter was able to emit the response. This capability is used by the provided EmitterStack to allow composing multiple emitters that can introspect the response to determine whether or not they are capable of emitting it. SapiEmitter Laminas\\HttpHandlerRunner\\Emitter\\SapiEmitter accepts the response instance, and uses the built-in PHP function header() to emit both the headers as well as the status line. It then uses echo to emit the response body. Internally, it also does a number of verifications: If headers have been previously sent, it will raise an exception. If output has been previously sent, it will raise an exception. These are performed in order to ensure the integrity of the response emitted. It also filters header names to normalize them; this is done in part to ensure that if multiple headers of the same name are emitted, the SAPI will report them correctly. This emitter can always handle a response, and thus always returns true. SapiStreamEmitter Laminas\\HttpHandlerRunner\\Emitter\\SapiStreamEmitter behaves similarly to the SapiEmitter , with two key differences: It allows emitting a a content range , if a Content-Range header is specified in the response. It will iteratively emit a range of bytes from the response, based on the buffer length provided to the emitter during construction. This is particularly useful when returning files or downloads . The emitter accepts an integer argument to the constructor, indicating the maximum buffer length; by default, this is 8192 bytes. This emitter can always handle a response, and thus always returns true. EmitterStack Laminas\\HttpHandlerRunner\\Emitter\\EmitterStack allows providing a last-in-first-out (LIFO) stack of emitters instead of a single emitter. If an emitter is incapable of handling the response and returns false , the stack will move to the next emitter. If an emitter returns true , the stack short-circuits and immediately returns. The EmitterStack extends SplStack , and thus allows you to add emitters using any of the methods that class defines; we recommend adding them in LIFO order using push() : $stack-&gt;push($last); $stack-&gt;push($second); $stack-&gt;push($first); Conditionally using the SapiStreamEmitter The SapiStreamEmitter is capable of emitting any response. However, for in-memory responses, you may want to use the more efficient SapiEmitter . How can you do this? One way is to check for response artifacts that indicate a file download, such as the Content-Disposition or Content-Range headers; if those headers are not present, you could return false from the emitter, and otherwise continue. You could achieve this by decorating the SapiStreamEmitter : $sapiStreamEmitter = new SapiStreamEmitter($maxBufferLength); $conditionalEmitter = new class ($sapiStreamEmitter) implements EmitterInterface { private $emitter; public function __construct(EmitterInterface $emitter) { $this-&gt;emitter = $emitter; } public function emit(ResponseInterface $response) : bool { if (! $response-&gt;hasHeader('Content-Disposition') &amp;&amp; ! $response-&gt;hasHeader('Content-Range') ) { return false; } return $this-&gt;emitter-&gt;emit($response); } }; $stack = new EmitterStack(); $stack-&gt;push(new SapiEmitter()); $stack-&gt;push($conditionalEmitter); In this way, you can have the best of both worlds, using the memory-efficient SapiStreamEmitter for large file downloads or streaming buffers, and the general-purpose SapiEmitter for everything else.","title":"Emitters"},{"location":"emitters/#emitters","text":"Emitters are used to emit a PSR-7 response. This should generally happen when running under a traditional PHP server API that uses output buffers, such as Apache or php-fpm. Emitters are described by Laminas\\HttpHandlerRunner\\Emitter\\EmitterInterface : use Psr\\Http\\Message\\ResponseInterface; interface EmitterInterface { public function emit(ResponseInterface $response) : bool; } Typically, such emitters will perform the following: Emit a response status line. Emit all response headers. Emit the response body. (The first two items may be swapped in order; many SAPIs allow emitting multiple status lines, and will use the last one present. As such, most implementations will emit the status line after the headers to ensure the correct one is emitted by the SAPI.) The emit() method allows returning a boolean. This value can be checked to determine if the emitter was able to emit the response. This capability is used by the provided EmitterStack to allow composing multiple emitters that can introspect the response to determine whether or not they are capable of emitting it.","title":"Emitters"},{"location":"emitters/#sapiemitter","text":"Laminas\\HttpHandlerRunner\\Emitter\\SapiEmitter accepts the response instance, and uses the built-in PHP function header() to emit both the headers as well as the status line. It then uses echo to emit the response body. Internally, it also does a number of verifications: If headers have been previously sent, it will raise an exception. If output has been previously sent, it will raise an exception. These are performed in order to ensure the integrity of the response emitted. It also filters header names to normalize them; this is done in part to ensure that if multiple headers of the same name are emitted, the SAPI will report them correctly. This emitter can always handle a response, and thus always returns true.","title":"SapiEmitter"},{"location":"emitters/#sapistreamemitter","text":"Laminas\\HttpHandlerRunner\\Emitter\\SapiStreamEmitter behaves similarly to the SapiEmitter , with two key differences: It allows emitting a a content range , if a Content-Range header is specified in the response. It will iteratively emit a range of bytes from the response, based on the buffer length provided to the emitter during construction. This is particularly useful when returning files or downloads . The emitter accepts an integer argument to the constructor, indicating the maximum buffer length; by default, this is 8192 bytes. This emitter can always handle a response, and thus always returns true.","title":"SapiStreamEmitter"},{"location":"emitters/#emitterstack","text":"Laminas\\HttpHandlerRunner\\Emitter\\EmitterStack allows providing a last-in-first-out (LIFO) stack of emitters instead of a single emitter. If an emitter is incapable of handling the response and returns false , the stack will move to the next emitter. If an emitter returns true , the stack short-circuits and immediately returns. The EmitterStack extends SplStack , and thus allows you to add emitters using any of the methods that class defines; we recommend adding them in LIFO order using push() : $stack-&gt;push($last); $stack-&gt;push($second); $stack-&gt;push($first);","title":"EmitterStack"},{"location":"intro/","text":"laminas-httphandlerrunner This component provides utilities for: Emitting PSR-7 responses. Running PSR-15 server request handlers, which involves marshaling a PSR-7 ServerRequestInterface , handling exceptions due to request creation, and emitting the response returned by the composed request handler. The RequestHandlerRunner will be used in the bootstrap of your application to fire off the RequestHandlerInterface representing your application.","title":"Introduction"},{"location":"intro/#laminas-httphandlerrunner","text":"This component provides utilities for: Emitting PSR-7 responses. Running PSR-15 server request handlers, which involves marshaling a PSR-7 ServerRequestInterface , handling exceptions due to request creation, and emitting the response returned by the composed request handler. The RequestHandlerRunner will be used in the bootstrap of your application to fire off the RequestHandlerInterface representing your application.","title":"laminas-httphandlerrunner"},{"location":"runner/","text":"The Request Handler Runner Laminas\\HttpHandlerRunner\\RequestHandlerRunner can be used to run a PSR-15 RequestHandlerInterface instance. By this, we mean: Marshal a server request instance. Handle exceptions due to marshaling the server request instance. Pass the request to the composed request handler. Pass the response generated by the request handler to the composed emitter The runner takes four constructor arguments, in the following order: A Psr\\Http\\Server\\RequestHandlerInterface instance. A Laminas\\HttpHandlerRunner\\Emitter\\EmitterInterface instance. A PHP callable to generate a Psr\\Http\\Message\\ServerRequestInterface instance. A PHP callable that can generate a Psr\\Http\\Message\\ResponseInterface instance given a PHP Throwable generated by the server request factory from the third argument. Once constructed, you may call the method run() : $runner-&gt;run(); Server request factory The $serverRequestFactory argument to the constructor may be any PHP callable that accepts no arguments (or all optional arguments), and which returns a PSR-7 ServerRequestInterface instance. As an example, using laminas-diactoros : use Laminas\\Diactoros\\ServerRequestFactory; $serverRequestFactory = [ServerRequestFactory::class, 'fromGlobals']; Alternately, a PSR-17 (proposed specification for HTTP message factories) factory may be used: use HttpInterop\\Implementation\\ServerRequestFactory; $serverRequestFactory = function () use ($_SERVER, $factory) { return $factory-&gt;createServerRequestFromArray($_SERVER); }; Server request error response generator In rare cases, the server request factory may raise a PHP Throwable or Exception . In those cases, the runner still needs to generate a response to emit. The server request error response generator argument to the RequestHandlerRunner constructor may be any PHP callable that accepts a PHP Throwable argument, and which returns a PSR-7 ResponseInterface instance. As an example, laminas-stratigility provides the class Laminas\\Stratigility\\Middleware\\ErrorResponseGenerator , which is typically used with its ErrorHandler to generate a response. It can be re-purposed if we curry in empty server request and response instances as follows: use Throwable; use Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\ServerRequest; use Laminas\\Stratigility\\Middleware\\ErrorResponseGenerator; $errorResponseGenerator = function (Throwable $e) { $generator = new ErrorResponseGenerator(); return $generator($e, new ServerRequest(), new Response()); }; Request handlers Request handlers MUST implement Psr\\Http\\Server\\RequestHandlerInterface . Additionally, for best results, they MUST provide their own error and exception handling, to ensure that a response is returned and the runner is able to emit a response.","title":"Request Handler Runner"},{"location":"runner/#the-request-handler-runner","text":"Laminas\\HttpHandlerRunner\\RequestHandlerRunner can be used to run a PSR-15 RequestHandlerInterface instance. By this, we mean: Marshal a server request instance. Handle exceptions due to marshaling the server request instance. Pass the request to the composed request handler. Pass the response generated by the request handler to the composed emitter The runner takes four constructor arguments, in the following order: A Psr\\Http\\Server\\RequestHandlerInterface instance. A Laminas\\HttpHandlerRunner\\Emitter\\EmitterInterface instance. A PHP callable to generate a Psr\\Http\\Message\\ServerRequestInterface instance. A PHP callable that can generate a Psr\\Http\\Message\\ResponseInterface instance given a PHP Throwable generated by the server request factory from the third argument. Once constructed, you may call the method run() : $runner-&gt;run();","title":"The Request Handler Runner"},{"location":"runner/#server-request-factory","text":"The $serverRequestFactory argument to the constructor may be any PHP callable that accepts no arguments (or all optional arguments), and which returns a PSR-7 ServerRequestInterface instance. As an example, using laminas-diactoros : use Laminas\\Diactoros\\ServerRequestFactory; $serverRequestFactory = [ServerRequestFactory::class, 'fromGlobals']; Alternately, a PSR-17 (proposed specification for HTTP message factories) factory may be used: use HttpInterop\\Implementation\\ServerRequestFactory; $serverRequestFactory = function () use ($_SERVER, $factory) { return $factory-&gt;createServerRequestFromArray($_SERVER); };","title":"Server request factory"},{"location":"runner/#server-request-error-response-generator","text":"In rare cases, the server request factory may raise a PHP Throwable or Exception . In those cases, the runner still needs to generate a response to emit. The server request error response generator argument to the RequestHandlerRunner constructor may be any PHP callable that accepts a PHP Throwable argument, and which returns a PSR-7 ResponseInterface instance. As an example, laminas-stratigility provides the class Laminas\\Stratigility\\Middleware\\ErrorResponseGenerator , which is typically used with its ErrorHandler to generate a response. It can be re-purposed if we curry in empty server request and response instances as follows: use Throwable; use Laminas\\Diactoros\\Response; use Laminas\\Diactoros\\ServerRequest; use Laminas\\Stratigility\\Middleware\\ErrorResponseGenerator; $errorResponseGenerator = function (Throwable $e) { $generator = new ErrorResponseGenerator(); return $generator($e, new ServerRequest(), new Response()); };","title":"Server request error response generator"},{"location":"runner/#request-handlers","text":"Request handlers MUST implement Psr\\Http\\Server\\RequestHandlerInterface . Additionally, for best results, they MUST provide their own error and exception handling, to ensure that a response is returned and the runner is able to emit a response.","title":"Request handlers"},{"location":"usage/","text":"Installation and Usage To install this package, run the following composer command: $ composer require laminas/laminas-httphandlerrunner The package provides both emitters and the request handler runner , and these are generally used within the bootstrap of your application. We recommend using a dependency injection container to define your various instances, including the PSR-15 request handler representing your application, the response emitter, the server request factory, the server request error response generator, potentially, the runner itself. The example below instantiates the runner manually by pulling its dependencies from a configured PSR-11 container. use Laminas\\HttpHandlerRunner\\Emitter\\EmitterStack; use Laminas\\HttpHandlerRunner\\RequestHandlerRunner; $container = require 'config/container.php'; $runner = new RequestHandlerRunner( $container-&gt;get(ApplicationRequestHandler::class), $container-&gt;get(EmitterStack::class), $container-&gt;get('ServerRequestFactory'), $container-&gt;get('ServerRequestErrorResponseGenerator') ); $runner-&gt;run();","title":"Usage"},{"location":"usage/#installation-and-usage","text":"To install this package, run the following composer command: $ composer require laminas/laminas-httphandlerrunner The package provides both emitters and the request handler runner , and these are generally used within the bootstrap of your application. We recommend using a dependency injection container to define your various instances, including the PSR-15 request handler representing your application, the response emitter, the server request factory, the server request error response generator, potentially, the runner itself. The example below instantiates the runner manually by pulling its dependencies from a configured PSR-11 container. use Laminas\\HttpHandlerRunner\\Emitter\\EmitterStack; use Laminas\\HttpHandlerRunner\\RequestHandlerRunner; $container = require 'config/container.php'; $runner = new RequestHandlerRunner( $container-&gt;get(ApplicationRequestHandler::class), $container-&gt;get(EmitterStack::class), $container-&gt;get('ServerRequestFactory'), $container-&gt;get('ServerRequestErrorResponseGenerator') ); $runner-&gt;run();","title":"Installation and Usage"}]}